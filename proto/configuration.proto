syntax = "proto3";

import "proto/modules.proto";
import "proto/transaction.proto";

package slog.internal;

message Replica {
    // List of all machine addresses in the system.
    // This list must have the size equal to number of partitions
    // If protocol is "tcp", these are IP addresses.
    // If protocol is "icp", these are filesystem paths.
    repeated bytes addresses = 1;
    // List of machines used for benchmarking. This field is only used by the admin tool
    repeated bytes client_addresses = 2;
}

message ReplicationDelayExperiment {
    // Percent of batches that are delayed
    uint32 delay_pct = 1;
    // Average duration of delay in milliseconds
    uint32 delay_amount_ms = 2;
}

/**
 * With hash partitioning, each key is interpreted as a byte string.
 * The keys are distributed to the partitions based on their
 * hash values.
 * Initial data can be loaded from an external file.
 */
message HashPartitioning {
    // Number of prefix bytes of a key to use for partitioning
    uint32 partition_key_num_bytes = 1;
}

/**
 * With simple partitioning, each key is assumed to be a number.
 * The keys are distributed to the partitions based on key values
 * modulo the number of partitions. 
 * Initial data cannot be loaded from an external file but can be
 * generated at startup. The following is an example of home and partition
 * assignment of the generated data with 3 partitions and 4 regions.
 *
 *        home | 0  1  2  3  0  1  2  3  0  ...
 * ------------|-------------------------------
 * partition 0 | 0  3  6  9  12 15 18 21 24 ...
 * partition 1 | 1  4  7  10 13 16 19 22 25 ...
 * partition 2 | 2  5  8  11 14 17 20 23 26 ...
 * ------------|-------------------------------
 *             |            keys            
 */
message SimplePartitioning {
    // Number of records to generate
    uint64 num_records = 1;
    // Size of a generated record in bytes
    uint32 record_size_bytes = 2;
}

message CpuPinning {
    ModuleId module = 1;
    uint32 cpu = 2;
}

message MetricOptions {
    uint32 txn_events_sample = 1;
    uint32 deadlock_resolver_runs_sample = 2;
    uint32 deadlock_resolver_deadlocks_sample = 3;
    bool deadlock_resolver_deadlock_details = 4;
    uint32 forw_sequ_latency_sample = 5;
    uint32 clock_sync_sample = 6;
    bool interleaver_logs = 7;
}

enum Commands {
    NOOP = 0;
    DUMMY = 1;
    KEY_VALUE = 2;
}

/**
 * The schema of a configuration file.
 */
message Configuration {
    // Protocol for the zmq sockets in the broker. Use "tcp" for
    // normal running and "icp" for unit and integration tests
    bytes protocol = 1;
    // Replica groups. Each group has a list of machine addresses
    // with the size equal to number of partitions
    repeated Replica replicas = 2;
    // Port for the zmq sockets in the broker. Each value will create a new broker thread
    repeated uint32 broker_ports = 3;
    // Port for the server
    uint32 server_port = 4;
    // Port for the forwarder
    uint32 forwarder_port = 5;
    // Port for the sequencer
    uint32 sequencer_port = 6;
    // Port for clock synchronizer. Set to 0 to disable clock synchronization
    uint32 clock_synchronizer_port = 7;
    // Number of partitions per replica
    uint32 num_partitions = 8;
    // Partitioning scheme
    oneof partitioning {
        HashPartitioning hash_partitioning = 9;
        SimplePartitioning simple_partitioning = 10;
    }
    // Number of worker threads for processing the transactions
    uint32 num_workers = 11;
    // How long the forwarder waits for batching
    uint64 forwarder_batch_duration = 12;
    // Maximum number of txns in a forwarder batch. Set to 0 for unlimited batch size
    int32 forwarder_max_batch_size = 13;
    // How long the sequencer waits for batching
    uint64 sequencer_batch_duration = 14;
    // Maximum number of txns in a sequencer batch. Set to 0 for unlimited batch size
    int32 sequencer_max_batch_size = 15;
    // Number of replicas that need to be synchronously replicated to
    uint32 replication_factor = 16;
    // Order of replicas for synchronous replication. This is a list of strings each of which corresponds
    // to a replica. Each string is an ordered comma-separated list of replica ids that the current replica
    // will synchronously replicate to based on replication order. The current replica will be ignored if exists
    // in the list. For example, ['1,2', '2,1,0', ''] means that, with a replication factor of 3, replica 0 will
    // synchronously replicate to 1 and 2, replica 1 will replicate to 2 and 0, and replica 2 will not synchronously
    // replicate to anywhere.
    repeated bytes replication_order = 17;
    // Replication of txn batches will be delayed to simulate uneven network latency
    ReplicationDelayExperiment replication_delay = 18;
    // Do not record specified events
    repeated TransactionEvent enabled_events = 19;
    // For multi-home txn, send lock-only txns directly to the regions, skipping the global orderer
    bool bypass_mh_orderer = 20;
    // Deadlock checking/resolving interval in ms. Set to 0 to disable deadlock resolving thread
    uint64 ddr_interval = 21;
    // Pin each module to a cpu
    repeated CpuPinning cpu_pinnings = 22;
    // Return dummy txns back to the client instead of full results
    bool return_dummy_txn = 23;
    // Number of retries after calling zmq::recv something
    int32 recv_retries = 24;
    // Type of commands to run while executing a txn 
    Commands commands = 25;
    // For each MH transaction, the involved regions will wait in such a way that their respective lock-only 
    // txns are put into the batches at approximately the same time
    bool synchronized_batching = 26;
    // Options for metrics
    MetricOptions metric_options = 27;
    // The ratio between fetching rate for remote logs message vs fetching rate for local log messages. Expressed
    // in the format "<remote>:<local>". For example "5:1" means the interleaver tries to fetch 5 messages for
    // remote logs before fetching 1 message for local log.
    bytes interleaver_remote_to_local_ratio = 28;
    // The forwarder sends probes to the sequencer to measure latency between current region and other regions on a set
    // interval. This interval is in ms.
    uint64 fs_latency_interval = 29;
    // Interval in ms for clock synchronizer to send messages
    uint64 clock_sync_interval = 30;
    // A txn is assigned a future timestamp, which will be equal to current time + latency to the furthest
    // region. When a txn arrives at a region, we want it to wait for a bit so that it can see other txns with
    // lower timestamp and get ordered after them. However, clocks are not perfectly synchronized and latency 
    // estimation may be off. The txn may arrive at a region A when time at A has already passed the txn's
    // timestamp. This value is thus used to extend the time a txn might be buffered at a region.
    int64 timestamp_buffer_us = 31;
    // Rolling window size used to average the latency measurement
    uint32 avg_latency_window_size = 32;
}